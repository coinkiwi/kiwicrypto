###
Author: Mariusz Nowostawski, and others. See AUTHORS.
Copyright (C) 2014 Mariusz Nowostawski, and others. See LICENSE.
###


#
#
#
# Arcfour, RC4 implementation.
# http://en.wikipedia.org/wiki/RC4
#
# POOL SIZE of 256 and modulo 256 operations are assumed.
#
class RC4

  i = 0
  j = 0
  S = new Array()

  #
  # Initialize arcfour context from a key, an array of ints, each from [0..255]
  #
  init: (key) ->
    for i in [0..255]
      S[i] = i
    j = 0

    for i in [0..255]
      j = (j + S[i] + key[i % key.length]) & 255
      [S[i], S[j]] = [S[j], S[i]]

    i = 0
    j = 0


  #
  # Return next value
  # @return [byte] new byte value from the sequence
  #
  next: () ->
    i = (i + 1) & 255
    j = (j + S[i]) & 255
    # swap values
    [S[i], S[j]] = [S[j], S[i]]
    # return
    S[(S[j] + S[i]) & 255]



#
# Random number generator.
# This implementatino uses RC4 as random number generator.
#
class Random

  # Pool size must be a multiple of 4 and greater than 32.
  # An array of bytes the size of the pool will be passed to init()
  @POOL_SIZE = 256

  state = undefined
  pool = null
  pptr = null


  # Initialize the pool and the random number generator.
  # This implementation uses RC4.
  constructor: () ->
    pool = new Array()
    pptr = 0

    while pptr < @POOL_SIZE
      t = Math.floor(65536 * Math.random())
      pool[pptr++] = t >>> 8
      pool[pptr++] = t & 255

    pptr = 0
    @mixinSeedTime()
    state = new RC4()
    state.init pool
    for i in [0..pool.length - 1]
      pool[i] = 0
    pptr = 0


  #
  # Mix in a 32-bit integer into the pool
  # @param x 32-bit integer to be mixed into the pool
  # @return [void]
  #
  mixinSeed: (x) ->
    pool[pptr++] ^= x & 255
    pool[pptr++] ^= (x >> 8) & 255
    pool[pptr++] ^= (x >> 16) & 255
    pool[pptr++] ^= (x >> 24) & 255
    if pptr >= @POOL_SIZE
      pptr -= @POOL_SIZE


  #
  # Mix in the current time in milliseconds into the entropy pool
  # @return [void]
  #
  mixinSeedTime: () ->
    @mixinSeed new Date().getTime()


  #
  # Generate new random byte.
  #
  # @return [byte] next randomly generated byte
  #
  nextByte: () ->
    state.next()



exports.Random = Random
